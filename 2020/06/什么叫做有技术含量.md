# 什么叫做"有技术含量"的开发

被人说现在的工作没有啥技术含量, 但我反问他啥叫有技术含量, 他也没有给出一个定义, 最后就一句"没现在的工作感觉就是没啥技术含量的工作". 这篇文章是我对技术含量的理解.

程序员的技术核心是啥? 大学的基本课程`数据结构`,`计算机组成原理`等很多工作中用不到课程, 只写CRUD是肯定用不到的. 为啥大学要教这些呢, 这些是计算机上和核心知识, 大量技术实现都依赖这些课程. 而应用到这些知识的地方一定是充满技术含量的. 那从这里出发就可以得出第一个结论, 在做减少时间复杂度和空间复杂度的地方可以体现出技术含量.

在读`计算机体系结构`的时候唯一的印象是cpu为了保证内存和cache之间数据一致性做出了大量的努力. 而一致性在计算机上是一个很重要的概念, 一致性经常被添加定语而扩展出新的含义, 比如"事务一致性", "数据一致性", "端到端一致性"等等. 而程序员很多时候都是为了性能和可靠性引入新的存储介质导致"数据一致性"的问题. 从这里得出了第二个结论, 在解决各种一致性问题

现在互联网最重要的一个高层协议\-\-`HTTP`. 对着这个协议的定义完全记录在RFC, 这里的每一句说明每一个次修改都是重要的(虽然有恶搞的协议). 每个协议都考虑了各种情况, 并做了对应解决方案, 这里不涉及任何实现只涉及规范, 期望实现某个协议都需要遵守规范. 这里提出第三个结论, 定义技术规范, 这里特指和程序员有关的编码, 传输等. 而这种规范要充分考虑各种失败和通用性.

代码会随着时间逐渐腐化, 代码复杂性会升高, 产品, 技术都在不断产生新的需求, 复制粘贴代码, 设计不合理, 这些代码最终会导致代码复杂度越来越高. 现在各种框架或组件的存在都是在引入一定复杂性而减少更多复杂性, spring的依赖注入和aop. 而技术含量也包含在这里, 对功能的开发引入的复杂性越少越好.

开源社区的各种中间件, Lucene, ES, Flink, rockesdb, mysql等等, 这些组件专注并系统的解决单一问题并提出新的模型, 这其中涉及到上面提到的每一个方面, 这种组件的设计和实现充分体现了技术含量.

因为[墨菲定律](https://github.com/nusr/hacker-laws-zh#%e5%a2%a8%e8%8f%b2%e5%ae%9a%e5%be%8b-murphys-law--sods-law) [wiki](https://zh.wikipedia.org/zh/%E6%91%A9%E8%8F%B2%E5%AE%9A%E7%90%86)的存在, 线上运行的系统只要可能出问题, 就一定会出问题. 就像地球磁场保护了大量的计算设备不出现严重的[单粒子翻转](https://zh.wikipedia.org/zh-hans/%E5%8D%95%E7%B2%92%E5%AD%90%E7%BF%BB%E8%BD%AC)情况. 硬件, 环境等等各种因素都会导致系统偶然性故障, 而这种故障都是无缘无故无法复现的. 为了解决这中问题, 引入"冗余存储", "水平扩展", "无状态服务", "自动化故障处理"等, 而解决这种问题同样体现了技术性.

分布式平台的设计和开发, 这个需要提供整套的开发组件和运维组件. 这其中充满了一致性和各种偶发性的问题. 而解决和设计这种系统是技术性的体现

## 中间结论
* 减少时间复杂度
    * 在有限资源下减少耗时, 不一定是算法优化
* 减少空间复杂度
    * 在有限资源下减少空间消耗, 不一定是算法优化
* 解决一致性问题
* 编写技术规范
* 减少系统复杂性
* 系统的解决单一问题
* 系统的故障解决方案
* 分布式系统设计和系列问题解决

## 继续思考

技术含量可以转换成这样一种解释, 只有少部分人可以做到而大部分人做不到的东西, 只有少部分人做到包含困难度太大, 太过简单而不愿做两种情况. 大部分人选择了放弃创造而是直接使用, 用最简单而重复的方案去实现业务\(嘴中没有技术含量的业务\). 而技术含量并不会体现在重复的业务中, 而是体现在对业务的抽象过程中, 通过抽象提炼出独特出模型并实践这个模型. 当反复的抽象和剥离业务最后结果就是一个技术含量颇高的组件, 最终这个组件得到众多人的使用. 对非创作者来说技术含量体现很多时候体现的是一个结果而不是过程, 当真的去做的时候发现琐碎的事情太多而放弃.

简单的总结, 不断减少复杂度和重复性的工作, 不断压榨计算机性能, 提高性能和空间使用率, 坚持做下去就可以了.



