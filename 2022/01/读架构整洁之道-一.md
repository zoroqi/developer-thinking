# 读架构整洁之道-一

第一我并没有读懂多少, 写下第一遍的感受方便第二次, 第三次阅读.

## 编程范式

正本书第一次感受到震撼的是这么一段描述

> 三个编程范式没有增加任何一个新功能, 只是限制了很多功能. 
> * 结构化编程是对**程序控制权的直接转移的限制**, 限制goto
> * 面向对象编程是对**程序控制权的间接转移的限制**, 限制函数指针
> * 函数式编程是对**程序中赋值操作的限制**, 限制赋值

三种编程范式都是 1958 年到 1968 年这十年间提出的, 后续没有新的编程范式出现过. **每个编程范式的目的都是*设置限制***; 这些编程范式主要是为了告诉我们**不能做什么, 而不是可以做什么**. 

看目录的时候直接看到"函数式编程"然后直接从第三章开始看的, 然后开始看 第二部分的内容. 

然后对 C++/Java 这种面向对象的抨击. 因为这两个语言自称是面向对象, 有着"继承, 封装, 多态"的特性, 但作者提出了证据说明这些语言破坏了 "继承, 封装, 多态". 

作者给出的面相对象的定义"面向对象编程就是以多态为手段来对源代码中依赖关系进行控制的能力, 这种能力让软件架构师可以构建某种插件是架构, 让高层策略性组件与底层实现性组件相分离, 底层组件可以被编译成插件, 实现独立于高层的开发和部署"

### 计算机语言

> 每一种编程范式都约束了某种编写代码的方式, 没有一个编程范式在增加能力. 今天构建软件的规则和 1946 年图灵写下点子计算机第一行代码时是一样的. 尽管工具变了, 硬件变了, 但是软件编程的核心没有变化. 

> 或者说计算机程序无一例外是有顺序结构, 分支结构, 循环结构, 间接转移这几种行为组合而成的, 无可增加, 也缺一不可.

我看过图灵的秘密, 这本书第一部分就是再讲图灵机构建的论文和图灵用图灵机写的第一个程序. 那个程序目标并不复杂, 但限于图灵机的一些限制, 那个程序异常难懂; 在第一个程序中图灵已经提出了"子程序"这个概念, 这个"子程序"就可以理解为现在开发语言中的"函数"了. 我读书的时候以为"函数"是之后才提出的.

## 简单的感受

控制业务逻辑的依赖顺序, 始终保持非核心业务依赖核心业务. 出现错误的依赖方向的时候, 就用接口等方案反转依赖关系.

程序员和架构师做出的每一个决定都是一次束缚, 当创建第一个文件后就有些选择不得不放弃. 当你执行了`go mod init` 后你等于放弃了泛型这个技术手段; 选了一个框架就会被框架束缚, 使用 Spring 框架后再想摆脱真的太困难了. 每一个束缚都是对未来代码开发的阻碍. 一个什么都没有的项目可以演变成一切, 但一个已经有几十万上百万行代码的项目, 只能再原始道路上艰难前行; 重构代码需要高超的技术手段, 更重要的是要有"魄力", 不成功便成仁的魄力.

架构是一个平衡的艺术, 需要控制核心和非核心的平衡. 那些东西放入到核心中, 那些放入到边缘内. 这些的选择需要时间, 经验, 能力的积累, 架构很多时候需要对未来做出预测, 预测那些事变的, 那些是不变的. 