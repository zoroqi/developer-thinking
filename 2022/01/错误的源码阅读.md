# 错误的源码阅读

最近工作上的同事干了一件让我很反感的事情, 就是在写业务逻辑的时候"思考依赖代码的具体实现".  而我关于学习源码最重要的一个原则就是"**源码要学习, 但实现的时候要忘记源码**"

阅读源码对程序员是重要的学习, 我实际上完整读完的源码只有两个项目一个是[oklog](https://github.com/oklog/oklog) 另一个是 [Tinyhttpd](https://github.com/EZLippi/Tinyhttpd), 两个项目都有所感悟. oklog 最大的触动就是实现状态机的方式, Tinyhttpd 的感触是 c 语言的 fork 函数. 虽然两个项目都已经不再更新了, 但依旧感触颇深.

我同事看过的源码就很多了, JDK 中的部分, Spring, RocketMQ 等等, 看源码我并不反对, 但是依据源码实现自己的业务逻辑就有问题了. 


```java
/// ... 入参一个 Map
inputMap.entrySet().stream().sort();
///
```

他是这么解释这行代码的"入参 inputMap, 转换成一个map, 通过流式处理对 map 中的元素进行排序", 我没反应过来"为啥 entrySet 会返回出一个 Map, 返回的不是一个 Set 吗?", 同时坚定的说出 "JDK 的 Set 是用 HashMap 实现的, 所以返回的是一个 Map". 

说一个更极端的例子, 这个例子是我听说的不一定真实. 反正 java 是可以做到的. 业务逻辑强依赖与 HashMap 的遍历顺序, 在一定数据内, 遍历顺序是确定的. 而这个神奇的业务逻辑导致项目无法升级 JDK 版本, 因为 1.8 以后 HashMap 的实现有着巨大改变, 这个遍历顺序会导致有问题.

这两个例子就很好的说明不要依据"实现的时候要依赖于接口的承诺或行为上的承诺, 而不是依赖于具体实现". 我在开发中经常看见一些特殊的优化方案, 这些方案都是需要对库有着深刻的理解\(也有可能是晚上的优化案例\); 这些优化都有个问题, 依赖库在未来某个版本就把这个特殊的功能取消了\(没有在接口或行为上进行说明, 只有看过源码的人才能知道\), 你的优化就完全没有意义了, 甚至还可能导致新的 bug.  

依赖库的改动导致很多优化失效的例子也是有的, 最经典的一个就是 JVM 的 CMS GC 算法, 在 9 中就改为不推荐了, 15 应该就移除了, 那在 CMS 参数上的所有"奇技淫巧"都没用了, 只能退回最老的几个 GC 算法, 要么直接 G1, ZGC 等等, 而且这些算法参数少很多. 

阅读源码重点是获取更多的知识, 设计经验, 加深对语言本身的理解, 学习作者做出这个决定的深意, 如何平衡多个实现之间的选择. 而不是为了炫耀和依据库的实现来写出针对性的优化代码.

当然这种现象可能就叫做知识的诅咒吧. 知识的诅咒: 就是一旦我们知道某样东西, 我们就会发现很难想象不知道它的时候会是什么样子. 
