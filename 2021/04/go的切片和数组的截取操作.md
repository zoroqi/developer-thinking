# go的切片和数组的截取操作

切片和数组从使用上是很相似的.

数组创建`[10]int{}`需要指定长度. 切片创建不需要指定长度`[]int{0,0}`, `make([]int,10)`, `make([]int,10,20)`都是可以, 最后切片或数组进行截取`a[:5]`.

切片配有专有操作, `append`, `copy`, 而数组并没有这个操作, 需要先转换再处理.

在看开源代码的时候发现一个特殊的操作, 在此记录一下.

```go
a := make([]int, 5, 10)
printSlice(a) // slice 5 10 [0 0 0 0 0]

b := a[6:10]
printSlice(b) // slice 4 4 [0 0 0 0]

c := a[:8]
printSlice(c) // slice 8 10 [0 0 0 0 0 0 0 0]

func printSlice(a []int) {
    fmt.Println(reflect.TypeOf(a).Kind(), len(a), cap(a), a)
}
```

我个人对`b`的和`c`的使用应该是引发panic, 但实际上并没有. 对数组的操作一定会引起panic, 数组好解释, 直接越界了, 访问了不属于自己的数据需要报错.

slice并没有产生相同的操作. 只要截取长度小于容量就不会panic. 所以在看开源代码就是用这种方式实现的扩容. 这种反直觉的操作\(至少是我的直觉\)的原因是, slice中获取索引的操作是收到长度限制的, 所以截取也应该受到同样的限制, 不能对一个未知的空间进行操作.

golang经常给我很多反直觉的操作, 不知道为啥这么做.
